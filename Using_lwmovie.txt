== Encoding videos for lwmovie ==
Authoring with lwmovie requires three steps:
1.) Encode the source video and audio using tools of your choice
2.) Import the source streams into raw lwmovie streams
3.) Finalize the video, which combines input streams also adds hinting data necessary to decode the video.

--- Importing streams ---
All importation is done with the "lwmux" utility.

lwmux importm1v <input.m1v> <output> - Imports MPEG-1 video and converts it to an lwmovie video stream.  This does not currently support multiplexed MPEG videos, you must demux the video and convert only the video.
lwmux importmp2 <input.mp2> <output> - Imports MPEG-1 layer II audio and converts it to an lwmovie audio stream.  This does not currently support multiplexed MPEG videos.

--- Multiplexing lwmovie streams ---
lwmux finalize <number of audio readahead samples> <audio> <video> <output> - Multiplexes an audio and video stream into a finished lwmovie.  You can enter "-" as the filename for a stream to omit the stream.  This does not currently support extracting streams from already-finalized lwmovies.



=== Decoding videos with lwmovie ===
lwmovie depends on the host application to perform timing and IO.  To avoid IO stalls, it instead provides decoding hints that specify how much data needs to be read ahead to avoid falling behind.

Before doing anything with lwmovie, you should call lwmInitialize to initialize it.  This should only be called once.

Once initialized, the next step to digesting a movie with lwmovie is to create a lwmSAllocator instance and pass it to lwmCreateMovieState.  The allocator should always return blocks allocated on SIMD boundaries and should not be destroyed until the movie state is destroyed.  The allocator instance passed to functions will always be the one passed back to the callbacks.  lwmCreateMovieState will return a lwmMovieState object if successful.

You can pass a bitmask of user flags to lwmCreateMovieState:
- lwmUSERFLAG_ThreadedDeslicer - Allows bitstream parsing to be thread pooled, but increases memory consumption.  If you use this, you should set a work notifier using lwmMovieState_SetVideoDigestWorkNotifier and the work notifier should call lwmMovieState_VideoDigestParticipate.

To digest data, pass a data buffer and the buffer size to lwmMovieState_FeedData.  lwmMovieState_FeedData will return a result code and the number of bytes that were digested, which may be zero.

Result codes and expected handling:
lwmDIGEST_Initialize - Indicates that lwmovie has finished parsing the stream header.  When this is returned, you should create a video reconstructor and assign it to the video using lwmMovieState_SetVideoReconstructor.  You can also access stream parameters at this point.  No further processing should be performed on the video until a reconstructor is assigned.
lwmDIGEST_Nothing - Indicates that lwmovie has made no progress on any operation and is awaiting more data.  If there is no more data to feed, then movie decoding is complete.
lwmDIGEST_Worked - Indicates that lwmovie has performed some internal work, even if it hasn't digested any data.
lwmDIGEST_FatalError - Indicates that lwmovie encountered an error and is unable to continue processing.
lwmDIGEST_VideoSync - Indicates that a new video frame is available.

=== Accessing video stream information ===
After lwmDIGEST_Initialize is received, you can access information about the video using lwmGetStreamParameterU32, including the dimensions, frame rate, and reconstructor type.

=== Software reconstructors ===
Decoding video requires a reconstructor.

To use the software reconstructor, you must first create a frame provider.  Frame providers serve work frames to the reconstructor.

System memory frame providers use a provided allocator and store results in main memory.  To create a system memory frame provider, call lwmCreateSystemMemoryFrameProvider.

Software reconstructors can be created using lwmCreateSoftwareReconstructor.  Always pass reconstructor creation functions the reconstructor type code received from lwmGetStreamParameterU32 with lwmSTREAMPARAM_U32_ReconType.

You can optionally assign a work notifier to the reconstructor using lwmVideoRecon_SetWorkNotifier, which should call lwmVideoRecon_Participate.

To retrieve output from a software reconstructor, wait for a lwmDIGEST_VideoSync result.  How to retrieve your video frame from that is determined by the reconstructor.

For software reconstruction:
- Call lwmVideoRecon_GetWorkFrame on the video reconstructor to get the current work frame index.
- Call the lockWorkFrameFunc member of the frame provider and pass the frame provider, the work frame index, and lwmVIDEOLOCK_Read to lock the frame.
- Call the getWorkFramePlaneFunc member of the frame provider and pass the frame provider, the work frame index, and the channel number to retrieve a pointer to the channel data.
- Call the getWorkFramePlaneStrideFunc member of the frame provider and pass the frame provider and the channel number to retrieve the offset of each row's starting data to the starting data of the next row.
- When done, call the unlockWorkFrameFunc member of the frame provider and pass the frame provider and the work frame index to unlock the frame.

=== Timing synchronization ===
When lwmovie returns a synchronization result, you can get the timestamp for the stream that finished using lwmGetStreamParameterU32 and the lwmSTREAMPARAM_U32_SyncPeriod parameter type.  The number of periods per second for a stream can be determined using lwmGetStreamParameterU32 with the lwmSTREAMPARAM_U32_PPSNumerator and lwmSTREAMPARAM_U32_PPSDenominator stream parameter types, which return the numerator and denominator of the periods-per-second fraction, respectively.

The timestamp represents the amount of data that the encoder has finished, including the data just processed, in periods.
- TODO

=== Additional topics ===
-- Full-range color --
  lwmovie supports full-range color, but full-range color is non-standard in MPEG-1 and requires either hacks or "tricking" the encoder.  You can get around this limit in ffmpeg by converting your movie to rawvideo using -pix_fmt yuvj420p and then encoding it using -pix_fmt yuv420p.


=== Thread pooling ===
lwmovie supports thread pooling by using lwmSWorkNotifier structures.

Work notifiers are expected to contain 2 fields:
- A "notifyAvailableFunc" callback that will be passed the work notifier instance new work is available.  The function should call a participate function appropriate for the type of work assigned to the work notifier exactly once.
- A "joinFunc" callback that will wait for all outstanding work assigned to the notifier to finish.

To assign a work notifier to the video digester, use lwmSetVideoDigestWorkNotifier and participate using lwmVideoDigestParticipate.
To assign a work notifier to the video reconstructor, use lwmSetVideoReconWorkNotifier and participate using lwmVideoReconParticipate.

=== Audio ===
lwmovie's audio decoding process uses a synchronization mechanism to ensure that playback can recover in the case of errors or stalls.  Audio samples returned by the decoder are intended to be queued consecutively, or played back immediately if no samples are queued.

Audio is in either a synchronized or unsynchronized state.  If audio is synchronized, then it means that audio playback started at the point that it became synchronized and any samples read have been queued for playback consecutively.

The recommended process for retrieving audio samples should be:
- When a video sync occurs:
    - Call lwmMovieState_IsAudioPlaybackSynchronized to determine if audio is synchronized
    - If audio is synchronized:
        - If the host playback system experienced an underrun (that is, it exhausted its queued samples):
            - Call lwmMovieState_NotifyAudioPlaybackUnderrun
        - Otherwise:
            - Use lwmMovieState_ReadAudioSamples to read audio samples
    - Otherwise:
        - If the host playback system is able to play audio samples immediately (that is, no leftover samples are still queued):
            - Call lwmMovieState_SynchronizeAudioPlayback to synchronize audio.
            - If lwmMovieState_SynchronizeAudioPlayback returned a non-zero value:
                - Use lwmMovieState_ReadAudioSamples to read audio samples

All of the operations except for synchronization itself can be performed at any time, not just at a video sync.  However, synchronization will only work after a video sync.

NOTE:
- Audio is NOT synchronized when movie playback begins.
- lwmovie may unsynchronize audio on its own, such as if a decode error occurs.
- lwmMovieState_SynchronizeAudioPlayback may not result in a successful synchronize, especially if audio is still being processed for future playback or a decode error occurs.


- lwmMovieState_ReadAudioSamples: Copies audio samples from a movie to a target buffer and returns the number of samples copied, up to the specified maximum, which should be played back after any already-retrieved samples.  If synchronized playback is stopped, this will return 0 samples, but it may also return 0 samples if there are no samples.
- lwmMovieState_IsAudioPlaybackSynchronized: Returns 1 if audio playback is synchronized, 0 if not.
- lwmMovieState_SynchronizeAudioPlayback: Synchronizes playback of audio with the most recent video time.  This should only be called if audio samples retrieved using lwmMovieState_ReadAudioSamples can be played back immediately.
- lwmMovieState_NotifyAudioPlaybackUnderrun: Unsynchronizes audio, allowing the audio decode system to resynchronize at a future point in time.


=== Cleaning up ===
To destroy a movie state, call lwmMovieState_Destroy and pass the movie state.
To destroy a video reconstructor, call lwmIVideoReconstructor_Destroy and pass the video reconstructor.
To destroy a frame provider, call lwmSVideoFrameProvider_Destroy and pass the frame provider.

When destroying video resources, you should destroy the movie state first, then the video reconstructor, then the frame provider.

=== Additional topics ===
-- Thread safety --
It is safe to digest multiple lwmovies at the same time in different threads.

Work participation may create jobs for other work notifiers, but will never create jobs for the participating notifier.

Work participation will never call the memory allocator.

-- Avoiding stalls when IO-bound --
Playing back video from devices that are restricted to a particular data rate may necessitate queuing playback data due to variations in bitrate even when using CBR encoding.  lwmovie does not currently provide a way to determine the amount of readahead necessary because that figure is based on both the video data and the exact IO limit.

One option that may help is passing lwmSTREAMPARAM_U32_LongestFrameReadAhead and lwmSTREAMTYPE_Video to lwmMovieState_GetStreamParameterU32, which will output the largest number of bytes that the video ever requires to digest and produce one video frame from the previous frame.

-- Security --
Currently, lwmovie is NOT expected to be safe when decoding untrusted data.
- TODO

-- Error recovery --
Currently, all errors in lwmovie are fatal.
- TODO